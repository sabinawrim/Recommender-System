# -*- coding: utf-8 -*-
"""sistem_rekomendasi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uBwRxOykx3XJvFT_9enmkb4JoKnGNBY-

# **Load Dataset**
Film: https://www.kaggle.com/datasets/parasharmanas/movie-recommendation-system/data
"""

import pandas as pd
import os
import zipfile

# mengimport module/mengunggah file dari komputer
from google.colab import files

upload = files.upload()

for fn in upload.keys():
  print('User uploaded file "{name}"'.format(
      name=fn))

# membuat direktori .kaggle
!mkdir ~/.kaggle

# memindahkan file json ke direktori .kaggle
!mv kaggle.json ~/.kaggle/

# # Ubah permission file
!chmod 600 ~/.kaggle/kaggle.json

# download dataset
!kaggle datasets download -d parasharmanas/movie-recommendation-system

# ekstrak file ZIP
with zipfile.ZipFile("movie-recommendation-system.zip", 'r') as zip_ref:
    zip_ref.extractall("movie_data")

# cek isi folder
os.listdir("movie_data")

"""# **Data Understanding**

Tujuan dari tahapan ini adalah untuk mendapatkan gambaran awal tentang struktur, isi, dan karakteristik data yang akan digunakan.
"""

# membaca data movies
df_movies = pd.read_csv("movie_data/movies.csv")
print(f'dimensi dataset: {df_movies.shape}')
df_movies.head()

"""Dataset movies.csv memiliki dimensi 62423 (baris) dan 3 (kolom/fitur). Berikut ini fitur pada data:
- movieId: variabel ini berisi ID unik untuk setiap film. Ini adalah pengenal numerik yang digunakan untuk membedakan satu film dari film lainnya dalam dataset.
- title: variabel ini berisi judul film. Variabel ini menyimpan judul dalam format string
- genres: variabel ini berisi informasi genre dari setiap film. Variabel ini menyimpan genre film dalam format string yang dipisahkan oleh '|'.
"""

# membaca data ratings
df_ratings = pd.read_csv("movie_data/ratings.csv")
print(f'dimensi dataset: {df_ratings.shape}')
df_ratings.head()

"""Dataset ratings.csv memiliki dimensi 25000095 (baris) dan 4 (kolom). Berikut ini fitur pada data:

- userId: variabel ini berisi ID unik untuk setiap pengguna (user) dalam dataset. Ini adalah pengenal numerik yang digunakan untuk membedakan satu pengguna dari pengguna lainnya.
-  movieId: variabel ini berisi ID unik untuk setiap film. Ini adalah pengenal numerik yang digunakan untuk membedakan satu film dari film lainnya dalam dataset. Variabel ini juga muncul di dataset movies.csv dan berfungsi sebagai kunci untuk menggabungkan informasi film dan rating.
- rating: variabel ini berisi nilai rating yang diberikan oleh seorang pengguna (userId) untuk film tertentu (movieId). Nilai rating menunjukkan preferensi pengguna terhadap film tersebut.
- timestamp: variabel ini berisi informasi waktu (dalam format timestamp) kapan rating tersebut diberikan oleh pengguna.

# **Univariate Exploratory Data Analysis**

***Data Movies***
"""

df_movies.info()

print('Jumlah data null: ')
print(df_movies.isnull().sum())
print('\nJumlah data duplikat: ', df_movies.duplicated().sum().sum())

# membersihkan judul
import re

def clean_title(title):
  return re.sub("[^a-zA-Z0-9 ]", "", title)

df_movies['title'] = df_movies['title'].apply(clean_title)

# memisahkan string genre menjadi daftar genre individual
df_movies['genres'] = df_movies['genres'].str.split('|')

movie_data = df_movies[['movieId', 'title', 'genres']]

df_movies.head()

# melihat jumlah judul film
print('Jumlah judul film: ', len(movie_data.title.unique()))
print('Jumlah genre film: ', movie_data.genres.explode().nunique())
print('Daftar genre film: ', movie_data.genres.explode().unique())

# menghitung jumlah film per genre
import matplotlib.pyplot as plt
import seaborn as sns

# hitung jumlah genre
count_genre = movie_data.genres.explode().value_counts().reset_index()
count_genre.columns = ['Genre', 'Jumlah Film']

# plot dengan seaborn
plt.figure(figsize=(10, 5))
sns.barplot(data=count_genre, x='Genre', y='Jumlah Film', palette='viridis', hue='Genre', legend=False)
plt.xlabel('Genre', fontsize=12)
plt.ylabel('Jumlah Film', fontsize=12)
plt.title('Jumlah Film Berdasarkan Genre', fontsize=14)
plt.xticks(rotation=90, ha='right')
plt.tight_layout()
plt.show()

"""Penjelasan Tahapan EDA pada data movie:
- Melihat informasi data. Terdapat 62423 baris dan 3 kolom.
- Mengecek missing value dan data duplikat. Tidak ada nilai nul dan data duplikat.
- Membersihkan judul film, dengan mengganti semua karakter dalam string yang bukan huruf(a-z, A-Z, 0-9, dan spasi) dengan string kosong(""), sehingga judul film hanya mengandung huruf, angka, dan spasi.
- Melihat jumlah film, jumlah genre, dan daftar genre film. Terdapat 20 daftar genre, dan ada genre dengan kategori '(no genres listed)'.
- Membuat visualisasi (diagram batang) untuk menampilkan distribusi jumlah film berdasarkan genre. Berdasarkan visualisasi film dengan genre drama paling banyak di data ini.

***Data Ratings***
"""

df_ratings.info()

df_ratings.isnull().sum()

df_ratings.duplicated().sum()

# melihat distribusi rating
print('Distribusi Rating: ')
print(df_ratings.rating.value_counts())

plt.figure(figsize=(10, 5))
sns.countplot(data=df_ratings, x='rating', palette='viridis', hue='rating', legend=False)
plt.xlabel('Rating', fontsize=12)
plt.ylabel('Jumlah Rating', fontsize=12)
plt.title('Distribusi Rating', fontsize=14)
plt.tight_layout()
plt.show()

# melihat rating rata-rata per film
rating_mean = df_ratings.groupby('movieId')['rating'].mean().reset_index()
rating_mean.head()

"""Penjelasan Tahapan EDA pada data ratings:
- Menampilkan informasi data. Ada 25000095 baris dan 4 kolom.
- Setelah di cek tidak ada missing value dan data duplikat.
- Melihat distribusi rating. Rating 4.0 paling banyak dan disusul dengan 3.0.

"""

# plot distribusi
plt.figure(figsize=(8, 4))
sns.histplot(data=rating_mean, x='rating', bins=20, kde=True, color='skyblue')
plt.xlabel('Rating', fontsize=12)
plt.ylabel('Jumlah Film', fontsize=12)
plt.title('Distribusi Rating Film', fontsize=14)
plt.tight_layout()
plt.show()

"""Visualisasi ini dibuat setelah menghitung rata-rata rating untuk setiap film yang ada di dataset. Plot histogram dan KDE ini menampilkan distribusi rating rata-rata per film. Sumbu X menunjukkan nilai rating rata-rata, dan Sumbu Y menunjukkan jumlah film. Visualisasi ini menunjukkan sebaran rating rata-rata film, di mana puncak grafik (nilai 3) mengindikasikan rentang rating rata-rata yang paling umum di dataset."""

# melihat rating rata-rata per pengguna
rating_user = df_ratings.groupby('userId')['rating'].mean().reset_index()
rating_user.head()

# plot distribusi
plt.figure(figsize=(8, 4))
sns.histplot(data=rating_user, x='rating', bins=20, kde=True, color='salmon')
plt.xlabel('Rating', fontsize=12)
plt.ylabel('Jumlah Pengguna', fontsize=12)
plt.title('Distribusi Rating Pengguna', fontsize=14)
plt.tight_layout()
plt.show()

"""Visualisasi ini dibuat setelah menghitung rata-rata rating yang diberikan oleh setiap pengguna dalam dataset. Dari plot ini kita dapat mengidentifikasi pola umum dalam cara pengguna memberikan rating. Dimaan puncak grafik mengindikasikan rentang rating rata-rata yang paling sering diberikan oleh pengguna, berdasarkan grefik adalah rentang 3-4.

# **Data Preprocessing**

***Movies Data***
"""

# memeriksa jumlah baris dengan genres '(no genres listed)'
count_no_genres_listed = movie_data['genres'].apply(lambda x: '(no genres listed)' in x).shape[0]
print('Jumlah baris dengan "(no genres listed)":', count_no_genres_listed)

# menghapus baris yang mengandung '(no genres listed)' dalam list genre
movie_data = movie_data[~movie_data['genres'].apply(lambda x: '(no genres listed)' in x)]

# menampilkan genre unik
unique_genres = pd.Series([genre for genres_list in movie_data['genres'] for genre in genres_list]).unique()
print('Jumlah genre film: ', len(unique_genres))
print("Genre Film:", unique_genres)

"""Menghapus baris yang bergenre '(no genres listed)' di dataset movies.

***Ratings Data***
"""

# menghapus kolom 'timestamp'
df_ratings.drop('timestamp', axis=1, inplace=True)
print(df_ratings.head())

# menggabungkan dataset ratings dan movies

combined_data = df_ratings.merge(movie_data, on='movieId')
combined_data

"""Menghapus kolom timestamp, karena tidak diperlukan dalam sistem rekomendasi. Kemudian Menggabungkan data ratings dan movies.

# **Data Preparation**
"""

# menghapus data duplikat di kolom 'userId'
combined_data= combined_data.drop_duplicates('userId')
combined_data

# menghapus data duplikat di kolom movieId
combined_data= combined_data.drop_duplicates('movieId')
combined_data

#  mengkonversi semua fitur dari data series ke bentuk list
user_id = combined_data['userId'].tolist()
movie_id = combined_data['movieId'].tolist()
rating = combined_data['rating'].tolist()
title = combined_data['title'].tolist()
genres = combined_data['genres'].tolist()

print(len(user_id))
print(len(movie_id))
print(len(rating))
print(len(title))
print(len(genres))

#  membuat dictionary
film_df = pd.DataFrame({
    'userId': user_id,
    'movieId': movie_id,
    'rating': rating,
    'title': title,
    'genres': genres
})

film_df

"""Pada tahapan ini dilakukan penghapusan data duplikat di kolom 'userId', dan 'movieId'. Kemudian mengkonversi semua fitur dari data series ke bentuk list, dan membuat ke bentuk dictionary dan data siap digunakan untuk tahapan modeling.

# **Model Development | Dengan Pendekatan Content Based Filtering**
"""

# saya akan membangun sistem rekomendasi film sederhana berdasarkan genre
# mengambil fitur movieId, title, dan genres dari film_df
df_cbf = film_df[['movieId', 'title', 'genres']]
df_cbf.head()

"""**TF-IDF Vectorizer**

TF-IDF Vectorizer akan digunakan pada sistem rekomendasi untuk menemukan representasi fitur penting dari setiap kategori genre.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# inisialisasi
tf = TfidfVectorizer()

# melakukan perhitungan idf pada data genres
tf.fit(df_cbf['genres'].apply(lambda x: ' '.join(x)))

# mapping  array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# melakukan fit lalu di transformasikan ke bentuk matrix
tfidf_matrix =tf.fit_transform(df_cbf['genres'].apply(lambda x: ' '.join(x)))

# melihat ukuran matrix tfidf
tfidf_matrix.shape

"""Nilai 1281 adalah ukuran data dan nilai 21 adalah matrik (jumlah) kategori genres"""

# untuk menghasilkan vektor tf-idf dalam bentuk matriks, kita menggunakan fungsi todense()
# mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis masakan
# Baris diisi dengan judul film

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=df_cbf.title
).sample(21, axis=1).sample(10, axis=0)

"""**Consine Similarity**"""

from sklearn.metrics.pairwise import cosine_similarity

# menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Menghitung cosine similarity dataframe tfidf_matrix yang sudah diperoleh pada tahapan sebelumnya. kode tersebut sudah berhasil menghitung similarity antar movie dan menampilkan output berupa matriks kesamaan dalam bentuk array."""

# melihat matriks kesamaan antar setiap film dengan menampilkan title (judul) dalam
# 5 sampel kolom (axis = 1) dan 10 sampel baris (axis=0).
cosine_sim_df = pd.DataFrame(cosine_sim, index=df_cbf['title'], columns=df_cbf['title'])
print('Shape:', cosine_sim_df.shape)

# melihat similarity matrix pada setiap film
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Membuat fungsi film_recommendations dengan beberapa parameter sebagai berikut:

- title : judul film (index kemiripan dataframe).
- Similarity_data : Dataframe mengenai similarity yang telah didefinisikan sebelumnya.
- Items : Nama dan fitur yang digunakan untuk mendefinisikan kemiripan, dalam hal ini adalah 'title' dan 'genres'.
- k : Banyak rekomendasi yang ingin diberikan.
"""

def film_recommendations(title, similarity_data=cosine_sim_df, items=df_cbf[['title', 'genres']], k=5):
    """
      Rekomendasi film berdasarkan kemiripan dataframe

      Parameter:
      ---
      title : tipe data string (str)
                  title film (index kemiripan dataframe)
      similarity_data : tipe data pd.DataFrame (object)
                        Kesamaan dataframe, simetrik, dengan film sebagai
                        indeks dan kolom
      items : tipe data pd.DataFrame (object)
              Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
      k : tipe data integer (int)
          Banyaknya jumlah rekomendasi yang diberikan
      ---


      Pada index ini, kita mengambil k dengan nilai similarity terbesar
      pada index matrix yang diberikan (i).
      """

    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)

    index = similarity_data.loc[:,title].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop title agar nama film yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

df_cbf[df_cbf.title.eq('Titanic 1997')]

"""Film Titanic 1997 masuk dalam kategori genre Drama dan Romance. Selanjutnya menguji fungsi film_recomendations untuk memberikan rekomendasi film dengan genre yang sama."""

film_recommendations('Titanic 1997')

"""Berhasil!!! sistem memberikan 5 rekomendasi film dengan kategori genre Drama dan Romance

# **Model Development | Dengan Pendekatan Collaborative Filtering**
"""

# Import library
import pandas as pd
import numpy as np
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt

df_cf = film_df
df_cf

"""**Data preparation**"""

# mengubah userId menjadi list tanpa nilai yang sama
user_ids = df_cf['userId'].unique().tolist()
print('list userId: ', user_ids)

# melakukan encoding userId
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
print('encoded userId: ', user_to_user_encoded)

# melakukan proses encoding angka ke userId
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
print('encoded angka ke userId: ', user_encoded_to_user)

# mengubah movieId list tanpa nilai yang sama
movie_ids = df_cf['movieId'].unique().tolist()
print('list movieId: ', movie_ids)

# melakukan proses encoding movieId
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}
print('encoded movieId: ', movie_to_movie_encoded)

# melakukan proses encoding angka ke movieId
movie_encoded_to_movie = {i: x for i, x in enumerate(movie_ids)}
print('encoded angka ke movieId: ', movie_encoded_to_movie)

"""Pada tahapan ini, kita perlu melakukan persiapan data untuk menyandikan (encode) fitur 'userId' dan 'movieId' ke dalam indeks integer yang berurut."""

# petakan userID dan placeID ke dataframe yang berkaitan.
df_cf['user'] = df_cf['userId'].map(user_to_user_encoded)
df_cf['movie'] = df_cf['movieId'].map(movie_to_movie_encoded)

# melihat datatype kolom rating
df_cf.dtypes

# melihat jumlah user
num_users = len(user_to_user_encoded)
print('jumlah user: ', num_users)

# melihat jumlah movie
num_movies = len(movie_to_movie_encoded)
print('jumlah movie: ', num_movies)

# nilai minimum rating
min_rating = min(df_cf['rating'])
print('nilai minimum rating: ', min_rating)

# nilai maksimum rating
max_rating = max(df_cf['rating'])
print('nilai maksimum rating: ', max_rating)

"""Tahapan preparation data sudah selesai. dimana kita sudah memahami data rating, menyandikan (encode) fitur 'userId' dan 'movieId' ke dalam indeks integer yang berurut, memetakan userId dan movieId ke dataframe yang berkaitan, dan mengecek jumlah user, jumlah movie, nilai min rating dan max rating.

**Membagi data untuk Training daan Validasi**
"""

# mengacak dataset
df_cf = df_cf.sample(frac=1, random_state=42)
df_cf

x = df_cf[['user', 'movie']].values
y = df_cf['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# membagi data 80:20
train_indices = int(0.8 * df_cf.shape[0])
x_train, x_val, y_train, y_val = (
    x[:train_indices],
    x[train_indices:],
    y[:train_indices],
    y[train_indices:],
)

print(x, '\n')
print(np.round(y, 1))

"""**Proses Training**


"""

class RecommenderNet(tf.keras.Model):

  # inisialisasi fungsi
  def __init__(self, num_users, num_movies, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_movies = num_movies
    self.embedding_size = embedding_size
    self.user_embedding = layers.Embedding(
      num_users,
      embedding_size,
      embeddings_initializer= 'he_normal',
      embeddings_regularizer=keras.regularizers.l2(1e-6),
    )
    self.user_bias = layers.Embedding(num_users, 1)
    self.movie_embedding = layers.Embedding(
      num_movies,
      embedding_size,
      embeddings_initializer= 'he_normal',
      embeddings_regularizer=keras.regularizers.l2(1e-6),
    )
    self.movie_bias = layers.Embedding(num_movies, 1)

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:, 0])
    user_bias = self.user_bias(inputs[:, 0])
    movie_vector = self.movie_embedding(inputs[:, 1])
    movie_bias = self.movie_bias(inputs[:, 1])

    dot_user_movie = tf.tensordot(user_vector, movie_vector, 2)

    x = dot_user_movie + user_bias + movie_bias

    return tf.nn.sigmoid(x) # activation sigmoid

# compile model
model = RecommenderNet(num_users, num_movies, 50)

model.compile(
  loss=tf.keras.losses.BinaryCrossentropy(),
  optimizer=keras.optimizers.Adam(learning_rate=0.001),
  metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""Model ini menggunakan Binary Crossentropy untuk menghitung loss function, Adam (Adaptive Moment Estimation) sebagai optimizer, dan root mean squared error (RMSE) sebagai metrics evaluation."""

# mulai proses training
history = model.fit(
  x=x_train,
  y=y_train,
  batch_size=16,
  epochs=50,
  validation_data=(x_val, y_val),
)

"""**Evaluasi**"""

# visualisasi metrik
plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

"""RMSE (Root Mean Squared Error): Ini adalah metrik evaluasi yang digunakan untuk mengukur seberapa dekat prediksi model dengan nilai sebenarnya. Nilai RMSE yang lebih rendah menunjukkan kinerja model yang lebih baik, karena artinya kesalahan prediksi rata-rata lebih kecil. Namun sepertinya ada overfitting, karena garis test berhenti menurun.

Dari proses ini, nilai erorr akhir sebesar 0.15 dan eror pada data validasi 0.31. Nilai tersebut cukup bagus untuk sistem rekomendasi. Selanjutnya cek apakah model ini bisa membuat rekomendaasi dengan  baik.

**Mendapatkan Rekomendasi Film**
"""

# memberikan rekomendasi film yang belum pernah di tonton
movie_df = film_df
df_cf = df_ratings

# mengambil sample user
user_id = df_cf.userId.sample(1).iloc[0]
movie_watched_by_user = df_cf[df_cf.userId == user_id]

movie_not_watched = movie_df[
  ~movie_df["movieId"].isin(movie_watched_by_user.movieId.values)
]["movieId"]
movie_not_watched = list(
  set(movie_not_watched).intersection(set(movie_to_movie_encoded.keys()))
)

movie_not_watched = [[movie_to_movie_encoded.get(x)] for x in movie_not_watched]
user_encoder = user_to_user_encoded.get(user_id)
user_movie_array = np.hstack(
  ([[user_encoder]] * len(movie_not_watched), movie_not_watched)
)

"""Selanjutnya, untuk memperoleh rekomendasi restoran, gunakan fungsi model.predict() dari library Keras dengan menerapkan kode berikut."""

import numpy as np

# memastikan user_movie_array adalah numpy array bertipe float
user_movie_array = np.array(user_movie_array, dtype=np.float32)

ratings = model.predict(user_movie_array).flatten()

# urutkan berdasarkan skor prediksi tertinggi
top_ratings_indices = ratings.argsort()[-10:][::-1]

# ambil ID movie yang direkomendasikan
recommended_movies_ids = [
    movie_encoded_to_movie.get(movie_not_watched[x][0]) for x in top_ratings_indices
]

# print hasil
print(f'Menampilkan rekomendasi untuk users: {user_id}')
print('=' * 27)
print('Movie dengan rating tinggi dari user')
print('----------------------------------------')

top_movie_user = (
    movie_watched_by_user.sort_values(by='rating', ascending=False)
    .head(5)
    .movieId.values
)

movie_df_rows = movie_df[movie_df["movieId"].isin(top_movie_user)]
for row in movie_df_rows.itertuples():
    print(row.title, ':', row.genres)

print('----------------------------------------')
print('Top 10 movies recommendation')
print('----------------------------------------')

recommended_movies = movie_df[movie_df['movieId'].isin(recommended_movies_ids)]
for row in recommended_movies.itertuples():
    print(row.title, ':', row.genres)

"""Berhasil! Hasil diatas adalah rekomendasi untuk user dengan id 104403. Dari output tersebut, sistem membandingkan antara film dengan rating tinggi dari user dan top 10 film rekomendasi untuk user.

10 Rekomendasi film (dan dilihat dari genre) yang diberikan sesuai dengan, film yang sudah diberi rating tinggi oleh user tersebut.
"""